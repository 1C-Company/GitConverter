При использовании [Технологии разветвленной разработки конфигураций](https://its.1c.ru/db/v8std/content/2149184358/hdoc) или аналогичного процесса для ветвления создается отдельное хранилище на каждую ветку на основе определенного номера закладки в основном хранилище. История в таком хранилище начинается с 1 версии и не содержит истории основного Хранилища.

## Цель
Создание сквозной истории изменений для "хранилищ исправительных версий" в ветке Git репозитория. "Авторство кода" (`git blame`) будет сквозным для веток.

## Настройки

1. Создаем [настройку конвертации](https://github.com/1C-Company/GitConverter/wiki/Настройка-конвертации-хранилища-1С) для "исправительного" хранилища.
   * Укажите `локальный каталог Git` репозитория отличающийся от основного хранилища
   * Укажите `адрес репозитория на сервере Git` такой же как в настройке основного хранилища
   * Укажите `имя ветки` например `release-1.2.1` имя ветки должно отличаться от имени, указанном в настройке конвертации основного хранилища.
2. Скопируйте локальный каталог репозитория Git для основного хранилища в каталог, указанный в текущей настройке. Убедитесь предварительно что в текущий момент не выполняются коммиты в основном, что локальный репозиторий не находится в состоянии модификации.
3. Найдите номер версии в основном хранилище на основе которого создано "исправительное" и скопируйте `хеш` коммита. 
    * выполните команду создания ветки на основе хеша в каталоге с локальным репозиторием исправительного хранилища:
    * `git checkout -b "release-1.2.1" c0c007b9dbe142a70e3bba57a6770a5e5ab3defb` - такая команда выполняет переключение состояния файлов на указанный хеш коммита и создает ветку с именем `release-1.2.1`
    * Удалите файлы `/MyProject/src/ConfigDumpInfo.xml` и `/MyProject/src/DumpFilesIndex.txt` в скопированном репозитории - эти файлы не хранятся в репозитории и используются для расчета частичной выгрузки и переименований файлов.

## РЕЗЮМЕ

Если вы нашли правильную версию в основном хранилище, то первая версия в "исправительном" будет ей равна и не содержит фактических изменений в файлах. Конвертация первой версии не приведет к добавлению нового коммита. Далее конвертация из "исправительного" хранилища продолжается как обычно, но в другую ветку. "Авторство кода" Git рассчитывает с учетом всех изменений, сделанных в основном хранилище.